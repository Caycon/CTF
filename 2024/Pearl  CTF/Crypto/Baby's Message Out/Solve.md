- Với source chall đã cho ta biết giá trị của q, s, r, t đều phụ thuộc vào p. Và việc tính toán n dựa trên p là ra nhanh chóng nên ta có thể thử các giá trị để giới hạn p.
```Python
from Crypto.Util.number import getPrime, isPrime, bytes_to_long
from math import log
import sys

n = pow(10, 5)
sys.setrecursionlimit(n)

def nextPrime(p):
    if isPrime(p):
        return p
    else:
        return nextPrime(p + 61)

c= 1838979268925267202615818395622122484893202706167722156383681963142079180161531237936585341507802530813847301831886857107840552940103096671213346624172927405178565892385733216702672851783423891229382579221604596673156151519463795808010572632138076246765227545034269340790242411584582692558549837221897037971538915332866933837117883228953143242965510280921618063635225603250391037969273250144174802927111408106890496901519737395485115788436384012937788617630381389196078818501905993385084557887716148781944416313908553565974546239241287340505018036547080504009483360838747251073440799502791555942879229132369697126614944991347408598924472158561247485575276852356316968119522601927483600978106155875300324966339458896992260918634629607740522754923275555209240690069838566642421234035117257380757518902549668151860260985363114235340791362277047923494577018035035653075155240898800910887230020812289524262582877697129108304758256250595391379019020972909027192107727799235384374670082518555887502478560056865020860127002
n= 485889862688353809145356849681869098056742135790325154633816315764783289109350404808839464043297429168130293002483316664607770068196944445394490388957147529192164743228508084885030734914365245916125607677185307000076761646830755541107131137865984020648243428286711853728051263128076845261298240617545417811431124904304446607845470628505361436115651109768237103000946120781642652665829238385087624612205525857191218811570122228639908283598707567056620352822139985271817003262919597858495812801663331842855143930997258260164422858382713240717739568744168349527025412634588705503126870149875268600539407786323924132037483972529603572727892740460450963315253482630345996561505957763886776070413535287129043703855880444326909520084249767518737040222995586717034060176093473694948961503759770499124924886087468497100053775745634680192678426965540847613838559522315570932873854027804486662281273550134766570419630624914801192395060568099367828616501877701994364906741451132770474154689411119296104818089636891131318495955929
# a= 9988236243777326596612403077329651780735894479264270104482043730894762106
# b= 3
a= 9
b= 75
c= 9
check = 1
for i in range(100):
        p= 10**b*(a*10+ c)
        try:
            print(p)
            q = nextPrime(nextPrime(17*p + 1) + 3)
            r = nextPrime(29*p*q)
            s = nextPrime(q*r + p)
            t = nextPrime(r*s*q)
            x= p*q*r*s*t
            if x> n:
                c= c- 1
            else:
                a= a*10+c
                b= b- 1
                c= 9 
        except:
            continue
print(f"p: {int(p)}")
print(f"n: {n}")
```
- Tuy nhiên ta sẽ gặp một vài trường hợp lỗi và bị out khi mà hàm `nextPrime` không tìm được số nguyên tố thỏa mãn.
- Khi ấy ta sẽ lấy giá trị tìm được nhiều nhất có thể đã tìm được của p và dựa vào đó thay đổi giá trị của a, b để tìm tiếp các giá trị còn lại.
- Ở đây sau vài lần thay đổi giá trị của a, b. Tôi đã tìm được giới hạn dưới của p là: `p= 99882362437773265966124030773296517807358944792642701044820437308947621060000`
- Ta tiến hàng brute force p và có được p
```Python
from Crypto.Util.number import getPrime, isPrime, bytes_to_long
from math import log
import sys

n = pow(10, 5)
sys.setrecursionlimit(n)

def nextPrime(p):
    if isPrime(p):
        return p
    else:
        return nextPrime(p + 61)
x= 99882362437773265966124030773296517807358944792642701044820437308947621060000
n= 485889862688353809145356849681869098056742135790325154633816315764783289109350404808839464043297429168130293002483316664607770068196944445394490388957147529192164743228508084885030734914365245916125607677185307000076761646830755541107131137865984020648243428286711853728051263128076845261298240617545417811431124904304446607845470628505361436115651109768237103000946120781642652665829238385087624612205525857191218811570122228639908283598707567056620352822139985271817003262919597858495812801663331842855143930997258260164422858382713240717739568744168349527025412634588705503126870149875268600539407786323924132037483972529603572727892740460450963315253482630345996561505957763886776070413535287129043703855880444326909520084249767518737040222995586717034060176093473694948961503759770499124924886087468497100053775745634680192678426965540847613838559522315570932873854027804486662281273550134766570419630624914801192395060568099367828616501877701994364906741451132770474154689411119296104818089636891131318495955929
for i in  range (1, 10000, 2):
    try: 
        p= x+ i
        if isPrime(p):
            print(i)
            q = nextPrime(nextPrime(17*p + 1) + 3)
            r = nextPrime(29*p*q)
            s = nextPrime(q*r + p)
            t = nextPrime(r*s*q)
            n1= p*q*s*r*t
            if n1== n:
                print(p)
                break
    except:
        continue
```
![image](https://hackmd.io/_uploads/Byd1Zn06a.png)
- Sau khi có được p ta decrypt RSA như bình thường và thu được flag.
```Python
from Crypto.Util.number  import *
from Crypto.Util.number import getPrime, isPrime, bytes_to_long
from math import log
import sys

n = pow(10, 5)
sys.setrecursionlimit(n)
def nextPrime(p):
    if isPrime(p):
        return p
    else:
        return nextPrime(p + 61)
n= 485889862688353809145356849681869098056742135790325154633816315764783289109350404808839464043297429168130293002483316664607770068196944445394490388957147529192164743228508084885030734914365245916125607677185307000076761646830755541107131137865984020648243428286711853728051263128076845261298240617545417811431124904304446607845470628505361436115651109768237103000946120781642652665829238385087624612205525857191218811570122228639908283598707567056620352822139985271817003262919597858495812801663331842855143930997258260164422858382713240717739568744168349527025412634588705503126870149875268600539407786323924132037483972529603572727892740460450963315253482630345996561505957763886776070413535287129043703855880444326909520084249767518737040222995586717034060176093473694948961503759770499124924886087468497100053775745634680192678426965540847613838559522315570932873854027804486662281273550134766570419630624914801192395060568099367828616501877701994364906741451132770474154689411119296104818089636891131318495955929
c= 1838979268925267202615818395622122484893202706167722156383681963142079180161531237936585341507802530813847301831886857107840552940103096671213346624172927405178565892385733216702672851783423891229382579221604596673156151519463795808010572632138076246765227545034269340790242411584582692558549837221897037971538915332866933837117883228953143242965510280921618063635225603250391037969273250144174802927111408106890496901519737395485115788436384012937788617630381389196078818501905993385084557887716148781944416313908553565974546239241287340505018036547080504009483360838747251073440799502791555942879229132369697126614944991347408598924472158561247485575276852356316968119522601927483600978106155875300324966339458896992260918634629607740522754923275555209240690069838566642421234035117257380757518902549668151860260985363114235340791362277047923494577018035035653075155240898800910887230020812289524262582877697129108304758256250595391379019020972909027192107727799235384374670082518555887502478560056865020860127002
p= 99882362437773265966124030773296517807358944792642701044820437308947621061961
q = nextPrime(nextPrime(17*p + 1) + 3)
r = nextPrime(29*p*q)
s = nextPrime(q*r + p)
t = nextPrime(r*s*q)
phi=(p-1)*(q-1)*(r-1)*(s-1)*(t-1)
e= 65537
d= pow(e, -1, phi)
flag= long_to_bytes(pow(c, d, n))
print(flag)
```
![image](https://hackmd.io/_uploads/rJsGz20pa.png)
